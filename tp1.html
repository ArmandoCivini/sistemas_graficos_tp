<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>
    <body>

    	<center>    		            
            <canvas id="my-canvas" width="1000" height="800">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>    		
    	</center>
        <script type='text/javascript' > 
            var colorMode = "wireframe";
        </script>
        <script type="text/javascript" src="js/gl-matrix.js"></script>
        <script type="text/javascript" src="droneCamera.js"></script>
        <script type="module" src="plane.js"></script>
        <script type="module" src="graphic_object.js"></script>
        <script type="module" src="test-object.js"></script>
        <script type="module" src="curves.js"></script>
        <script type="module" src="sweep_surface.js"></script>
        <script type="module" src="circle.js"></script>



        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;

            uniform vec3 surfaceColor;
            uniform bool colorNormals;

            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {
                if (colorNormals) {
                    vec3 vNormalNormal = normalize(vNormal);
                    vec3 lightVec=normalize(vec3(0.0,3.0,5.0)-vPosWorld);
                    vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormalNormal,0.4);
                    vec3 color=dot(lightVec,vNormalNormal)*diffColor+vec3(0.2,0.2,0.2);
                    gl_FragColor = vec4(color,1.0);
                } else {
                    gl_FragColor = vec4(surfaceColor,1.0);
                }
            }
        </script>
        
        <script type="module">
            import {Plane} from "./plane.js";
            import {TestObject} from "./test-object.js";
            import {Form} from "./form.js";
            import {Circle} from "./circle.js";
            import {SweepSurface} from "./sweep_surface.js";
            import {SweepClosedSurface} from "./sweep_closed_surface.js";
            import {RevSurface} from "./rev_surface.js";
            import {Line} from "./line.js";
            import {createTerrain} from "./terrain.js";
            import {castleFloor} from "./castle_floor.js";
            import {Window} from "./window.js";
            import {castleStructure} from "./castle_structure.js";
            import {CurveForm} from "./curve_form.js";
            import {createTower} from "./tower.js";
            import {createWall} from "./wall.js";
            import {GraphicObject} from "./graphic_object.js";
            import {createEnciente} from "./enciente.js";

            var mat4=glMatrix.mat4;
            var vec3=glMatrix.vec3;

            var gl = null,
            canvas = null,

            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
                
            var vertexPositionAttribute = null,
            trianglesVerticeBuffer = null,
            vertexNormalAttribute = null,
            trianglesNormalBuffer = null,
            trianglesIndexBuffer = null;
               
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            var normalMatrix = mat4.create();
            var rotate_angle = -1.57078;
            
            let droneCam=new DroneCameraControl([0,0,10]);

            var plane1 = null;
            var testObject = null;
            var some_surface = null;
            var castle_floor = null;
            var terrain = null;
            var castle_structure = null;
            var test_object = null;
            var plane2 = null;
            var top_floor = null;
            // var colorMode = "wireframe";
         
            function initWebGL(){

                canvas = document.getElementById("my-canvas");  

                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {

                    setupWebGL();
                    initShaders();
                    setupBuffers();
                    setupVertexShaderMatrix();
                    tick();   

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function setupWebGL(){
                gl.enable(gl.DEPTH_TEST);
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, 100.0);
                
                mat4.identity(modelMatrix);
                mat4.rotate(modelMatrix,modelMatrix, -1.57078, [1.0, 0.0, 0.0]);

                mat4.identity(viewMatrix);
                mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, -5.0]);
            }
                    
                    
            function initShaders() {
                //get shader source
                var fs_source = document.getElementById('shader-fs').innerHTML,
                    vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type){
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }

            function setupBuffers() {
                var rows=4;
                var cols=4;
                let height = -0.3;
                let len = 1;
                // some_surface = createHalfWall(gl, glProgram, height);
                // some_surface = createWall(gl, glProgram, height, 1);
                // some_surface.translate(0, 1, 0);
                // some_surface.rotate(0, 0, -Math.PI/2);
                // test_object = new GraphicObject(gl, 0, 0, glProgram);
                // test_object.setAsNode();
                // plane1 = createHalfWall(gl, glProgram, height);
                // test_object.addChild(plane1);
                // test_object.rotate(0, Math.PI, 0);
//culo
                plane1 = createEnciente(gl, glProgram, 5, 12);
                // plane1.translate(0, -1, -0.4);

                castle_structure = castleStructure(gl, glProgram, 1, 8, 8);
                terrain = createTerrain(gl, glProgram);
                terrain.scale(1.3,1.3,1.3);

                // plane2 = new GraphicObject(gl, 0, 0, glProgram);
                // plane2.setAsNode();
                // let plane2_child = new Plane(gl, rows, cols, glProgram);
                // plane2.addChild(plane2_child);
                // // plane2.rotate(5 *Math.PI/12,0,0);
                // plane2.rotate(-Math.PI/2,0,0);

                // plane1 = new Plane(gl, rows, cols, glProgram);
                // plane1.translate(0, -1, 0);
                // plane1.scale(1, 1, 30);
                // plane1.rotate(-Math.PI/2,0,0);
                // // plane2.translate(0,0,-1.2);
                // let point1 = [0, -len/2, 0];
                // let point2 = [0, -len/4, 0];
                // let point3 = [0, len/4, 0];
                // let point4 = [0, len/2, 0];
                
                // let controlPoints1 = [point1, point2, point3, point4];

                // // point1 = [0.0+height, 0-(height/4), 0];
                // // point2 = [0.1+height, -0.05-(height/4), 0];
                // // point3 = [0.2, 0.05, 0];
                // // point4 = [0.3, 0, 0];
                // // let controlPoints2 = [point1, point2, point3, point4];

                // point1 = [0.0+height, 0-(height/4), 0];
                // point2 = [0.1+height, -0.05-(height/4), 0];
                // point3 = [0.2, 0.05, 0];
                // point4 = [0.3, 0, 0];
                // // point1 = [-len/2, 0, 0];
                // // point2 = [-len/4, 0, 0];
                // // point3 = [len/4, 0, 0];
                // // point4 = [len/2, 0, 0];
                // let controlPoints2 = [point1, point2, point3, point4];

                // let half_wall_curve = new CurveForm(128, controlPoints2);

                // // test_object = new SweepSurface(controlPoints1, 16, half_wall_curve, gl, glProgram, [0.49020, 0.49020, 0.49804]);
                // let start = {
                //     x: 0,
                //     y: -0.1,
                //     z: 0,
                // };
                // let finish = {
                //     x: 0,
                //     y: -0.15,
                //     z: 0,
                // };
                // let normal = {
                //         x: 1,
                //         y: 0,
                //         z: 0,
                // };
                // top_floor = new SweepSurface(controlPoints1, 16, new Line(16, start, finish, normal), gl, glProgram, [0.49020, 0.49020, 0.49804]);
                // top_floor.translate(0, 0, 0);
                // top_floor.rotate(0, Math.PI/2, 0);
            }

            function setupVertexShaderMatrix(){
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");

                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
            }                  
            
            function drawScene(){
                setupVertexShaderMatrix();

                plane1.draw();
                // plane2.draw();
                // test_object.draw();
                // if (rotate_angle > 1) {
                //     castle_structure = castleStructure(gl, glProgram, 3);
                // }
                castle_structure.draw();
                terrain.draw();
                // some_surface.draw();
                // top_floor.draw();
            }

            function animate(){
                
                rotate_angle = 0.01;
                let rotated = Math.PI/2;
                // if (rotate_angle > 1) {
                //     const colorNormals = gl.getUniformLocation(glProgram, "colorNormals");           
                //     gl.uniform1i(colorNormals, true);
                // }
                // plane1.updateViewMatrix(viewMatrix);
                // some_surface.translate(0, 0, 3);
                // plane1.rotate(0, rotate_angle, 0);
                // some_surface.rotate(0, rotate_angle, 0);
                // some_surface.scale(2, 1, 1);
                // some_surface.updateViewMatrix(viewMatrix);
                // some_surface.translate(3, 0, 0);
                // some_surface.rotate(0, rotated, 0);
                // some_surface.rotate(rotated, 0, 0);

                // testObject.updateViewMatrix(viewMatrix);
                // testObject.rotate(rotate_angle, 0, rotate_angle);
                // testObject.applyTransformations();

                // plane2.updateViewMatrix(viewMatrix);
                // plane2.rotate(0, 0, rotate_angle);
                // plane2.applyTransformations();
            }
            
            function tick(){

                viewMatrix=droneCam.getViewMatrix();

                requestAnimationFrame(tick);
                droneCam.update();
                drawScene();
                animate();
            }

            window.onload=initWebGL;

        </script>


    </body>
</html>
